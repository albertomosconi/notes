\documentclass[12pt, letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=15mm, includefoot]{geometry}

\usepackage{eurosym}

\usepackage{titlesec}
\titleformat{\section}
{\newpage\Large\bfseries}{\thesection}{1em}{}
[\titlerule]

\renewcommand*\contentsname{Contents}

\setlength{\parskip}{1mm}
\setlength{\parindent}{0em}

\begin{document}

\begin{titlepage}
    
    \vspace*{2cm}
    
    \begin{center}
        \huge{\bfseries Bioinformatics Algorithms} \\[10pt]
        \Large{Lecture Notes} \\[10pt]
        \large{a.a. 2020/2021} \\
    \end{center}
    
    \vfill
    
    \begin{flushleft}        
        \large
        \textbf{Alberto Mosconi} \\
        \normalsize
        Politecnico di Milano
    \end{flushleft}
    
\end{titlepage}

\thispagestyle{empty}
\tableofcontents
\newpage

\setcounter{page}{1}

\section{Definitions}

\subsection{Alphabet}
Let $\Sigma$ be a finite set of symbols (alternatively called characters), called the alphabet. No assumption is made about the nature of the symbols.

\subsection{Strings}
A string (or word) over $\Sigma$ is any finite sequence of symbols from $\Sigma$. For example if $\Sigma = \{0,1\}$ then $01011$ is a string over $\Sigma$.

The \textbf{length of a string \emph{S} is the number of symbols} in \emph{s} (the length of the sequence) and can be any non-negative integer. It is often denoted as $|S|$.

The \textbf{empty string} is the unique string over $\Sigma$ of length 0, and is denoted as $\epsilon$.

The \textbf{set of all strings over $\mathbf{\Sigma}$ of length \emph{n}} is denoted $\mathbf{\Sigma^n}$. For example , if $\Sigma = {0, 1}$, then $\Sigma^2 = \{00, 01, 10, 11\}$. Note that $\Sigma^0 = \{\epsilon\}$ for any alphabet $\Sigma$.

The \textbf{set of all strings of any length over $\mathbf{\Sigma}$} is the \emph{Kleene closure} of $\Sigma$ and is denoted as $\mathbf{\Sigma^*}$. Also: 
$$
\Sigma^* = \bigcup_{n \in {N} \cup \{0\}} \Sigma^n
$$

The \textbf{set of all non-empty strings over $\mathbf{\Sigma}$} is denoted by $\mathbf{\Sigma^+}$

\subsection{Subsequences}

A \textbf{subsequence} of S is a string that can be \textbf{obtained by deleting any number (from 0 to n) of non-consecutive characters} from S, including S and the empty string too.

\subsubsection{Let us count: subsequences}

A subsequence of S can be described by a binary string B of n elements, telling us for each position i if the corresponding character is kept in the subsequence (1) or deleted (0).

\begin{itemize}
\item S = apple, B = 11010 $\rightarrow$ subsequence = apl
\end{itemize}

Thus, the \textbf{number of subsequences} corresponds to the number of binary strings of length n, hence 
$$
subsequences = 2^n
$$

Notice that if two subsequences produced by different choices are \textbf{identical, they will be counted twice}.

\subsection{Substrings}

A string \emph{s} is said to be a \textbf{substring} (or \emph{factor}) of \emph{t} if there exist (possibly empty) strings \emph{u} and \emph{v} such that \emph{t = usv}.

Given a string \emph{t}, \textbf{suffixes} and \textbf{prefixes} are special substrings of \emph{t}.

\subsubsection{Let us count: substrings}

Given a string of length \emph{n}:

\begin{itemize}
\item We have 1 substring of length \emph{n} (starting at 1)
\item We have 2 substrings of length \emph{n-1} (starting at 1 and 2)
\item We have 3 substrings of length \emph{n-2} (starting at 1,2 and 3)
\item ...
\item We have $n-i+1$ substrings of length $i$ (starting at all positions from 1 to $n-i+1$)
\item We have \emph{n} substrings of length 1 (starting at every position)
\end{itemize}

Plus, 1 substring of length 0.

This brings the \textbf{total number of substrings} of a string of length \emph{n} to
$$
substrings = \sum^n_{i=1}i=\frac{n(n+1)}{2}+1
$$

\subsection{Prefixes and suffixes}

A string \emph{s} is said to be a \textbf{prefix} of \emph{t} if there exists a string \emph{u} such that \emph{t = su}. If \emph{u} is nonempty, \emph{s} is said to be a \emph{proper} prefix of \emph{t}.

Simmetrically, a string \emph{s} is said to be a \textbf{suffix} of \emph{t} if there exists a string \emph{u} such that \emph{t = us}. If \emph{u} is nonempty, \emph{s} is said to be a \emph{proper} suffix of \emph{t}.

\subsubsection{Let us count: prefixes and suffixes}

The number of all posssible prefixes/suffixes of a string of length n is
\begin{center}
\emph{prefixes/suffixes} $= n + 1$
\end{center}

\textbf{n are non-empty, +1} because we include also \textbf{the empty string} as prefix/suffix.

\subsection{Reverse and palindrome}

The \textbf{reverse} of a string is a string with the same symbols but in reverse order. For example, if \emph{s = abc} (where \emph{a}, \emph{b}, and \emph{c} are symbols of the alphabet), then the reverse of \emph{s} is \emph{cba}.

A string that is the reverse of itself is called a \textbf{palindrome}, which also includes the empty string and all strings of length 1.

\subsection{Rotations and permutations}

A string \emph{s = uv} is said to be a \textbf{rotation} of \emph{t} if \emph{t = vu}. For example, if $\Sigma = \{0, 1\}$ the string \emph{0011001} is a rotation of \emph{0100110}, where \emph{u = 00110} and \emph{v = 01}.

\subsubsection{Let us count: rotations}
Given a string S, with $|S| = n$, we denote \textbf{S=AB}, where \textbf{A is a prefix} substring, and \textbf{B a suffix} substring.

For every possible pair A, B the string \textbf{R=BA is a rotation of S}, including S itself, that is, the case where $A=\epsilon$ and $B=S$.

Since we have n different non empty suffixes B, the number of rotations is
$$
rotations = n
$$

It is not \emph{n + 1} because the two suffixes $B=S$ and $B=\epsilon$ produce exactly the same rotation, given by S itself.

\subsubsection{Let us count: permutations}

Given a string S, with $|S| = n$, the number of permutations of the characters in S is
$$
permutations = n!
$$

Notice that the formula does not consider the case of indentical permutations: that is, a string of \emph{n} identical characters, will have \emph{n} identical permutations.

\section{String comparison and alignment}

\subsection{Hamming distance}

The \textbf{Hamming distance} between \textbf{two strings of equal length} is the \textbf{number of positions at which the corresponding symbols are different}.

\begin{itemize}
\item ``ka\emph{rol}in'' and ``ka\emph{thr}in'' $\rightarrow$ 3
\item 10\emph{1}1\emph{1}01 and 10\emph{0}1\emph{0}01 $\rightarrow$ 2
\end{itemize}

With Hamming distance we can formalize \emph{substitutions} in biological sequences - or simply sequencing errors in which the wrong base pair is identified.

\subsection{Edit distance}

The \textbf{edit distance} is a way of quantifying how dissimilar two strings (e.g., words) are to one another by counting the \textbf{minimum number of operations required to transform on string into the other}.

In the \emph{Levenshtein distance} (the most common), edit operations are: \textbf{removal}, \textbf{insertion}, and \textbf{substitution}.

The edit distance between ``kitten'' and ``sitting'' is 3. A minimal edit script that transforms the former into the latter is:

\begin{itemize}
\item \textbf{k}itten $\rightarrow$ \textbf{s}itten (substitute \emph{s} for \emph{k})
\item sitt\textbf{e}n $\rightarrow$ sitt\textbf{i}n (substitute \emph{i} for \emph{e})
\item sittin $\rightarrow$ sittin\textbf{g} (insert \emph{g} at the end)
\end{itemize}

The number of solutions (sequences of operations) is infinite.

\subsubsection{Computing the edit distance}

We denote as $E(S, T)$ the edit distance between two strings \emph{S} and \emph{T}.

For every string \emph{S}, $E(S, \epsilon) = |S|$, that is:
\begin{itemize}
\item the edit distance between a string \emph{S} and the empty string $\epsilon$ equals the length of \emph{S}.
\item also, $E(\epsilon, \epsilon)=0$: the edit distance between two empty strings is zero.
\end{itemize}

Let $S = s_1s_2...s_n$ and $T = t_1t_2...t_m$ be two strings:
\begin{itemize}
\item we denote as $S(i)$ the prefix of length \emph{i} of \emph{S} $\rightarrow S(i) = s_1s_2...s_i$
\item likewise, as $T(j)$ the prefix of length \emph{j} of \emph{T} $\rightarrow T(j) = t_1t_2...t_j$
\end{itemize}
\newpage

Now, to compute the edit distance $E(S, T)$ between two strings \emph{S} and \emph{T}, with $|S| = n$ characters, and $|T|=m$ characters, a technique of dynamic programming is used. 

We can easily calculate the edit distance of two substrings of \emph{S} and \emph{T}, with length \emph{i} and \emph{j}, if we have the edit distance of the two ``previous" substrings, that is, the substrings of length $i-1$ and $j-1$.

To do so we prepare a matrix with $|S| + 1$ rows and $|T| + 1$ columns, numbered starting from 0.\\

\textbf{The cell(i, j) will contain the value of the edit distance between prefixes S(i) and T(j).}

We can fill the first row and first column right away since we know that $\forall i, E(S(i), \epsilon) = i$ and that $\forall j, E(T(j), \epsilon) = j$.

\setlength{\tabcolsep}{18pt}
\renewcommand{\arraystretch}{1.5}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
& \textbf{-} & \textbf{H} & \textbf{O} & \textbf{M} & \textbf{E} \\
\hline
\textbf{-} & 0 & 1 & 2 & 3 & 4 \\
\hline
\textbf{H} & 1 & & & & \\
\hline
\textbf{O} & 2 & & & & \\
\hline
\textbf{U} & 3 & & & & \\
\hline
\textbf{S} & 4 & & & & \\
\hline
\textbf{E} & 5 & & & & \\
\hline
\end{tabular}
\end{center}

Now, the value of each cell can be calculated with this formula.

$$
E(S(i), T(j)) = \min \left\{\begin{array}{rcl}
E(S(i), T(j-1)) + 1 \\ 
E(S(i-1), T(j)) + 1 \\
E(S(i-1), T(j-1)) & \mbox{if} & s_i = t_j \\
E(S(i-1), T(j-1)) +1 & \mbox{if} & s_i \neq t_j \\
\end{array}
\right.
$$

That is, \textbf{the edit distance between $\mathbf{S(i)}$ and $\mathbf{T(j)}$ depends on the edit distances computed for their prefixes}.

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
& \textbf{-} & \textbf{H} & \textbf{O} & \textbf{M} & \textbf{E} \\
\hline
\textbf{-} & 0 & 1 & 2 & 3 & 4 \\
\hline
\textbf{H} & 1 & 0 & 1 & 2 & 3 \\
\hline
\textbf{O} & 2 & 1 & 0 & 1 & 2 \\
\hline
\textbf{U} & 3 & 2 & 1 & 1 & 2 \\
\hline
\textbf{S} & 4 & 3 & 2 & 2 & 2 \\
\hline
\textbf{E} & 5 & 4 & 3 & 3 & 2 \\
\hline
\end{tabular}
\end{center}

Every cell M(i, j) contains the edit distance between prefixes S(i) and T(j). \textbf{Cell M(n, m) contains the edit distance between S(n) and T(m), that is E(S, T)}.

\subsubsection{Computational complexity of edit distance}

The table has $(n + 1) x (m + 1)$ cells to be filled, hence
$$
\mbox{\textbf{space complexity }} \mathbf{= \Theta(nm)}
$$

For every cell, the time required for the computation is constant (i.e. does not depend on the size of input strings), hence, the algorithm performs $(n+1)x(m+1)$ steps of constant time. Thus
$$
\mbox{\textbf{time complexity }} \mathbf{= \Theta(nm)}
$$

\end{document}


















