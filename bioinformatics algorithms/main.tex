\documentclass[12pt, letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=15mm, includefoot]{geometry}

\usepackage{eurosym}
\usepackage{colortbl}
\usepackage{tikz}
\usetikzlibrary{tikzmark}

\usepackage{titlesec}
\titleformat{\section}
{\newpage\Large\bfseries}{\thesection}{1em}{}
[\titlerule]

\renewcommand*\contentsname{Contents}

\setlength{\parskip}{1mm}
\setlength{\parindent}{0em}

\begin{document}

\begin{titlepage}
    
    \vspace*{2cm}
    
    \begin{center}
        \huge{\bfseries Bioinformatics Algorithms} \\[10pt]
        \Large{Lecture Notes} \\[10pt]
        \large{a.a. 2020/2021} \\
    \end{center}
    
    \vfill
    
    \begin{flushleft}        
        \large
        \textbf{Alberto Mosconi} \\
        \normalsize
        Politecnico di Milano
    \end{flushleft}
    
\end{titlepage}

\thispagestyle{empty}
\tableofcontents
\newpage

\setcounter{page}{1}

\section{Definitions}

\subsection{Alphabet}
Let $\Sigma$ be a finite set of symbols (alternatively called characters), called the alphabet. No assumption is made about the nature of the symbols.

\subsection{Strings}
A string (or word) over $\Sigma$ is any finite sequence of symbols from $\Sigma$. For example if $\Sigma = \{0,1\}$ then $01011$ is a string over $\Sigma$.

The \textbf{length of a string \emph{S} is the number of symbols} in \emph{s} (the length of the sequence) and can be any non-negative integer. It is often denoted as $|S|$.

The \textbf{empty string} is the unique string over $\Sigma$ of length 0, and is denoted as $\varepsilon$.

The \textbf{set of all strings over $\mathbf{\Sigma}$ of length \emph{n}} is denoted $\mathbf{\Sigma^n}$. For example , if $\Sigma = {0, 1}$, then $\Sigma^2 = \{00, 01, 10, 11\}$. Note that $\Sigma^0 = \{\varepsilon\}$ for any alphabet $\Sigma$.

The \textbf{set of all strings of any length over $\mathbf{\Sigma}$} is the \emph{Kleene closure} of $\Sigma$ and is denoted as $\mathbf{\Sigma^*}$. Also: 
$$
\Sigma^* = \bigcup_{n \in {N} \cup \{0\}} \Sigma^n
$$

The \textbf{set of all non-empty strings over $\mathbf{\Sigma}$} is denoted by $\mathbf{\Sigma^+}$

\subsection{Subsequences}

A \textbf{subsequence} of S is a string that can be \textbf{obtained by deleting any number (from 0 to n) of non-consecutive characters} from S, including S and the empty string too.

\subsubsection{Let us count: subsequences}

A subsequence of S can be described by a binary string B of n elements, telling us for each position i if the corresponding character is kept in the subsequence (1) or deleted (0).

\begin{itemize}
\item S = apple, B = 11010 $\rightarrow$ subsequence = apl
\end{itemize}

Thus, the \textbf{number of subsequences} corresponds to the number of binary strings of length n, hence 
$$
subsequences = 2^n
$$

Notice that if two subsequences produced by different choices are \textbf{identical, they will be counted twice}.

\subsection{Substrings}

A string \emph{s} is said to be a \textbf{substring} (or \emph{factor}) of \emph{t} if there exist (possibly empty) strings \emph{u} and \emph{v} such that \emph{t = usv}.

Given a string \emph{t}, \textbf{suffixes} and \textbf{prefixes} are special substrings of \emph{t}.

\subsubsection{Let us count: substrings}

Given a string of length \emph{n}:

\begin{itemize}
\item We have 1 substring of length \emph{n} (starting at 1)
\item We have 2 substrings of length \emph{n-1} (starting at 1 and 2)
\item We have 3 substrings of length \emph{n-2} (starting at 1,2 and 3)
\item ...
\item We have $n-i+1$ substrings of length $i$ (starting at all positions from 1 to $n-i+1$)
\item We have \emph{n} substrings of length 1 (starting at every position)
\end{itemize}

Plus, 1 substring of length 0.

This brings the \textbf{total number of substrings} of a string of length \emph{n} to
$$
substrings = \sum^n_{i=1}i=\frac{n(n+1)}{2}+1
$$

\subsection{Prefixes and suffixes}

A string \emph{s} is said to be a \textbf{prefix} of \emph{t} if there exists a string \emph{u} such that \emph{t = su}. If \emph{u} is nonempty, \emph{s} is said to be a \emph{proper} prefix of \emph{t}.

Simmetrically, a string \emph{s} is said to be a \textbf{suffix} of \emph{t} if there exists a string \emph{u} such that \emph{t = us}. If \emph{u} is nonempty, \emph{s} is said to be a \emph{proper} suffix of \emph{t}.

\subsubsection{Let us count: prefixes and suffixes}

The number of all posssible prefixes/suffixes of a string of length n is
\begin{center}
\emph{prefixes/suffixes} $= n + 1$
\end{center}

\textbf{n are non-empty, +1} because we include also \textbf{the empty string} as prefix/suffix.

\subsection{Reverse and palindrome}

The \textbf{reverse} of a string is a string with the same symbols but in reverse order. For example, if \emph{s = abc} (where \emph{a}, \emph{b}, and \emph{c} are symbols of the alphabet), then the reverse of \emph{s} is \emph{cba}.

A string that is the reverse of itself is called a \textbf{palindrome}, which also includes the empty string and all strings of length 1.

\subsection{Rotations and permutations}

A string \emph{s = uv} is said to be a \textbf{rotation} of \emph{t} if \emph{t = vu}. For example, if $\Sigma = \{0, 1\}$ the string \emph{0011001} is a rotation of \emph{0100110}, where \emph{u = 00110} and \emph{v = 01}.

\subsubsection{Let us count: rotations}
Given a string S, with $|S| = n$, we denote \textbf{S=AB}, where \textbf{A is a prefix} substring, and \textbf{B a suffix} substring.

For every possible pair A, B the string \textbf{R=BA is a rotation of S}, including S itself, that is, the case where $A=\varepsilon$ and $B=S$.

Since we have n different non empty suffixes B, the number of rotations is
$$
rotations = n
$$

It is not \emph{n + 1} because the two suffixes $B=S$ and $B=\varepsilon$ produce exactly the same rotation, given by S itself.

\subsubsection{Let us count: permutations}

Given a string S, with $|S| = n$, the number of permutations of the characters in S is
$$
permutations = n!
$$

Notice that the formula does not consider the case of indentical permutations: that is, a string of \emph{n} identical characters, will have \emph{n} identical permutations.

\section{String comparison}

\subsection{Hamming distance}

The \textbf{Hamming distance} between \textbf{two strings of equal length} is the \textbf{number of positions at which the corresponding symbols are different}.

\begin{itemize}
\item ``ka\emph{rol}in'' and ``ka\emph{thr}in'' $\rightarrow$ 3
\item 10\emph{1}1\emph{1}01 and 10\emph{0}1\emph{0}01 $\rightarrow$ 2
\end{itemize}

With Hamming distance we can formalize \emph{substitutions} in biological sequences - or simply sequencing errors in which the wrong base pair is identified.

\subsection{Edit distance}

The \textbf{edit distance} is a way of quantifying how dissimilar two strings (e.g., words) are to one another by counting the \textbf{minimum number of operations required to transform on string into the other}.

In the \emph{Levenshtein distance} (the most common), edit operations are: \textbf{removal}, \textbf{insertion}, and \textbf{substitution}.

The edit distance between ``kitten'' and ``sitting'' is 3. A minimal edit script that transforms the former into the latter is:

\begin{itemize}
\item \textbf{k}itten $\rightarrow$ \textbf{s}itten (substitute \emph{s} for \emph{k})
\item sitt\textbf{e}n $\rightarrow$ sitt\textbf{i}n (substitute \emph{i} for \emph{e})
\item sittin $\rightarrow$ sittin\textbf{g} (insert \emph{g} at the end)
\end{itemize}

The number of solutions (sequences of operations) is infinite.

\subsubsection{Computing the edit distance}

We denote as $E(S, T)$ the edit distance between two strings \emph{S} and \emph{T}.

For every string \emph{S}, $E(S, \varepsilon) = |S|$, that is:
\begin{itemize}
\item the edit distance between a string \emph{S} and the empty string $\varepsilon$ equals the length of \emph{S}.
\item also, $E(\varepsilon, \varepsilon)=0$: the edit distance between two empty strings is zero.
\end{itemize}

Let $S = s_1s_2...s_n$ and $T = t_1t_2...t_m$ be two strings:
\begin{itemize}
\item we denote as $S(i)$ the prefix of length \emph{i} of \emph{S} $\rightarrow S(i) = s_1s_2...s_i$
\item likewise, as $T(j)$ the prefix of length \emph{j} of \emph{T} $\rightarrow T(j) = t_1t_2...t_j$
\end{itemize}
\newpage

Now, to compute the edit distance $E(S, T)$ between two strings \emph{S} and \emph{T}, with $|S| = n$ characters, and $|T|=m$ characters, a technique of dynamic programming is used. 

We can easily calculate the edit distance of two substrings of \emph{S} and \emph{T}, with length \emph{i} and \emph{j}, if we have the edit distance of the two ``previous" substrings, that is, the substrings of length $i-1$ and $j-1$.

To do so we prepare a matrix with $|S| + 1$ rows and $|T| + 1$ columns, numbered starting from 0.\\

\textbf{The cell(i, j) will contain the value of the edit distance between prefixes S(i) and T(j).}

We can fill the first row and first column right away since we know that $\forall i, E(S(i), \varepsilon) = i$ and that $\forall j, E(T(j), \varepsilon) = j$.

\setlength{\tabcolsep}{18pt}
\renewcommand{\arraystretch}{1.5}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
& \texttt{-} & \textbf{H} & \textbf{O} & \textbf{M} & \textbf{E} \\
\hline
\textbf{-} & 0 & 1 & 2 & 3 & 4 \\
\hline
\textbf{H} & 1 & & & & \\
\hline
\textbf{O} & 2 & & & & \\
\hline
\textbf{U} & 3 & & & & \\
\hline
\textbf{S} & 4 & & & & \\
\hline
\textbf{E} & 5 & & & & \\
\hline
\end{tabular}
\end{center}

Now, the value of each cell can be calculated with this formula.
$$
E(S(i), T(j)) = \min \left\{\begin{array}{rcl}
E(S(i), T(j-1)) + 1 \\ 
E(S(i-1), T(j)) + 1 \\
E(S(i-1), T(j-1)) & \mbox{if} & s_i = t_j \\
E(S(i-1), T(j-1)) +1 & \mbox{if} & s_i \neq t_j \\
\end{array}
\right.
$$

That is, \textbf{the edit distance between $\mathbf{S(i)}$ and $\mathbf{T(j)}$ depends on the edit distances computed for their prefixes}.

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
& \textbf{-} & \textbf{H} & \textbf{O} & \textbf{M} & \textbf{E} \\
\hline
\textbf{-} & 0 & 1 & 2 & 3 & 4 \\
\hline
\textbf{H} & 1 & 0 & 1 & 2 & 3 \\
\hline
\textbf{O} & 2 & 1 & 0 & 1 & 2 \\
\hline
\textbf{U} & 3 & 2 & 1 & 1 & 2 \\
\hline
\textbf{S} & 4 & 3 & 2 & 2 & 2 \\
\hline
\textbf{E} & 5 & 4 & 3 & 3 & \cellcolor[gray]{0.9}2 \\
\hline
\end{tabular}
\end{center}

Every cell M(i, j) contains the edit distance between prefixes S(i) and T(j). \textbf{Cell M(n, m) contains the edit distance between S(n) and T(m), that is E(S, T)}.

\subsubsection{Computational complexity of edit distance}

The table has $(n + 1) x (m + 1)$ cells to be filled, hence
$$
\mbox{\textbf{space complexity }} \mathbf{= \Theta(nm)}
$$

For every cell, the time required for the computation is constant (i.e. does not depend on the size of input strings), hence, the algorithm performs $(n+1)x(m+1)$ steps of constant time. Thus
$$
\mbox{\textbf{time complexity }} \mathbf{= \Theta(nm)}
$$

\subsubsection{Traceback}

Once the table has been built, and the edit distance between the two strings has been computed, one may want to know the exact sequence of operations (insertions, deletions and substitutions) that transform the first string into the second.

To allow this, during the creation of the matrix, every time each cell is filled we \textbf{not only save the score value, but also which of the 3 previous cells had the minimum value}.

\newcommand{\tabel}[2]
{\tikzmark{#2l} #1 \tikzmark{#2r}}
\newcommand{\tabln}[2]
{\draw [->]({pic cs:#1l}) to ({pic cs:#2r});}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
& \textbf{-} & \textbf{H} & \textbf{O} & \textbf{M} & \textbf{E} \\
\hline
\textbf{-} & \cellcolor[gray]{0.9}\tabel{0}{0} & \tabel{1}{1} & \tabel{2}{2} & \tabel{3}{3} & \tabel{4}{4} \\
\hline
\textbf{H} & \tabel{1}{5} & \cellcolor[gray]{0.9}\tabel{0}{6} & \tabel{1}{7} & \tabel{2}{8} & \tabel{3}{9} \\
\hline
\textbf{O} & \tabel{2}{10} & \tabel{1}{11} & \cellcolor[gray]{0.9}\tabel{0}{12} & \tabel{1}{13} & \tabel{2}{14} \\
\hline
\textbf{U} & \tabel{3}{15} & \tabel{2}{16} & \tabel{1}{17} & \cellcolor[gray]{0.9}\tabel{1}{18} & \tabel{2}{19} \\
\hline
\textbf{S} & \tabel{4}{20} & \tabel{3}{21} & \tabel{2}{22} & \cellcolor[gray]{0.9}\tabel{2}{23} & \tabel{2}{24} \\
\hline
\textbf{E} & \tabel{5}{25} & \tabel{4}{26} & \tabel{3}{27} & \tabel{3}{28} & \cellcolor[gray]{0.9}\tabel{2}{29} \\
\hline
\end{tabular}
\begin{tikzpicture}[overlay, remember picture, shorten >=.5pt, shorten <=.5pt, transform canvas={yshift=.25\baselineskip}, thick]
	\tabln{1}{0}
	\tabln{2}{1}
	\tabln{3}{2}
	\tabln{4}{3}
	\draw [->]({pic cs:5l}) to ({pic cs:0l});
	\draw [->]({pic cs:10l}) to ({pic cs:5l});
	\draw [->]({pic cs:15l}) to ({pic cs:10l});
	\draw [->]({pic cs:20l}) to ({pic cs:15l});
	\draw [->]({pic cs:25l}) to ({pic cs:20l});
	\draw [->]({pic cs:11l}) to ({pic cs:6l});
	\tabln{7}{6}
	\tabln{8}{7}
	\tabln{9}{8}
	\tabln{12}{6}
	\draw [->]({pic cs:16l}) to ({pic cs:11l});
	\draw [->]({pic cs:21l}) to ({pic cs:16l});
	\draw [->]({pic cs:26l}) to ({pic cs:21l});
	\tabln{6}{0}
	\tabln{13}{12}
	\tabln{14}{13}
	\tabln{18}{12}
	\draw [->]({pic cs:17l}) to ({pic cs:12l});
	\tabln{24}{18}
	\tabln{19}{18}
	\draw [->]({pic cs:22l}) to ({pic cs:17l});
	\draw [->]({pic cs:23l}) to ({pic cs:18l});
	\draw [->]({pic cs:27l}) to ({pic cs:22l});
	\draw [->]({pic cs:28l}) to ({pic cs:23l});
	\tabln{29}{23}
\end{tikzpicture}
\end{center}

Now, if we \textbf{start from the final cell}, we can follow the pointers until we reach the top-left corner and deduce the sequence of edit operations from the type of moves that form the path.
\begin{itemize}
\item \textbf{Diagonal move}: when the path makes a diagonal move there are two possibilities, depending on whether the characters that identify the start cell match or not:
	\begin{itemize}
	\item if they are \textbf{the same}, \textbf{no operation} is applied.
	\item if they \textbf{don't match}, a \textbf{substitution} takes place.
	\end{itemize}
\item \textbf{Vertical move}: during a vertical move an \textbf{insertion} takes place: the current character of the second string is inserted into the first string.
\item \textbf{Horizontal move}: when a horizontal move occurs a character is \textbf{deleted} from the first string.
\end{itemize}

In the case of the example above the sequence of moves and the corresponding operations are:
\begin{enumerate}
\item \textbf{E, E $\rightarrow$ M, S:} diagonal move, E is equal to E so \textbf{no operation}.
\item \textbf{M, S $\rightarrow$ M, U:} vertical move, M and S don't match so \textbf{S is inserted in the first string}.
\item \textbf{M, U $\rightarrow$ O, O:} diagonal move, M and U don't match so \textbf{M is substituted with U}.
\item \textbf{O, O $\rightarrow$ H, H:} diagonal move, O is equal to O, so \textbf{no operation}.
\item \textbf{H, H $\rightarrow$ -, -:} diagonal move, H is equal to H, so \textbf{no operation}.
\end{enumerate}

We can shorten this representation like so:
\begin{center}
\tt 
S - - U N D A Y \\
S A T U R D A Y
\end{center}

\subsubsection{Weighted edit distance}

\subsection{Longest Common Subsequence}


\section{Alignment}

\subsection{Global alignment}

\subsection{Local alignment}

\section{Pattern matching}

\subsection{Exact pattern matching}

\subsubsection{The naive approach}

\subsubsection{Knuth-Morris-Pratt algorithm}






\end{document}


















